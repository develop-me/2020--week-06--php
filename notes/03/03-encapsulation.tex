So far, all of the PHP code you've written has been ``procedural'': start at the top of a file, run through it, maybe call a few functions as you go, and then finish at the end. This is fine for simple programs or when we're just working inside an existing system (e.g. WordPress), but it doesn't really scale to larger applications.
\\

The problem comes because we need to manage \textbf{state}: keeping track of all the values in our code. For a large app you could easily have thousands of values that need storing. Naming and keeping track of all these variables would become a nightmare if they were all in the same global scope.
\\

\textbf{Object-Oriented Programming}\footnote{``Oriented'' not ``Orientated''.} (OOP) is one way to make this easier. The key idea behind OOP is \textbf{encapsulation}: we keep functions and variables that are related to each other in one place (an object) and then use visibility to limit which bits of code can access and change them.
\\

An object is effectively a black box: objects can send \textbf{messages} to each other (by calling methods), but they need not have any knowledge of the inner workings of other objects.


\pagebreak


\begin{infobox}{The Unusual History of PHP}
    PHP has a long and complicated history. The first version of PHP wasn't even a programming language, it was just simple templating language that allowed you to re-use the same HTML code in multiple files.

    \quoteinline{I don't know how to stop it, there was never any intent to write a programming language \textellipsis{} I have absolutely no idea how to write a programming language, I just kept adding the next logical step on the way.}{Rasmus Lerdorf, Creator of PHP}

    Over the years PHP morphed into a simple programming language and then into a modern object-oriented programming language. However, it wasn't really until 2009, with the release of PHP 5.3, that PHP could truly be considered a fully object-oriented language.
    \\

    Because of this gradual change, older PHP frameworks and systems (such as WordPress) were originally written using non-OO code, which is why they still contain a large amount of procedural code.
    \\

    PHP gets a lot of flack for not being a very good programming language and a few years ago that was perhaps a valid criticism. But in recent years, particularly with the release of PHP 7, it's just not true anymore. It certainly still has some issues, but nothing that a few libraries can't get around.

    \quoteinline{There are only two kinds of languages: the ones people complain about and the ones nobody uses}{Bjarne Stroustrup, Creator of C++}
\end{infobox}

\pagebreak

Say that our app includes some code to send an email. If we were using procedural code we would probably have a function called \texttt{sendMail} that we can pass various values to:

\php{}{03/figures/03/01-mail}

But we might want to be able to customise more than just the to, from, and message parts of the email. Which means we'd either need to have a lot of optional arguments (which becomes unwieldy quickly) or rely on global variables:

\php{}{03/figures/03/02-global-mail}

But this is truly horrible: we have no way of preventing other parts of our code from changing these values and we would start having to use long variable names to avoid ambiguity in bigger apps.
\\

So, we want to store the variables and the functionality together in one place and in such a way that values can't be accidentally changed. This is where objects come in:

\php{}{03/figures/03/03-mail-class}

Now if we need to add additional fields, we can just add a property and setter method.


\section{Object-Oriented Programming}

In OOP objects use other objects to get things done. Rather than use variables and functions, pretty much everything is an object instance and we use properties and methods. The key skill of OOP is getting the right objects to talk to one another.
\\

For example, say that we have various users on our website and we want to send them our regular mailing list email. In procedural code we'd probably write something like:

\begin{minted}{php}
    $userEmails = getUserEmailsFromDatabase();

    foreach ($userEmails as $address) {
        sendEmail($address, "Subject", "Message");
    }
\end{minted}

In OOP it might look something like this:

\begin{minted}{php}
    $users = Users::all(); // get all the users
    $email = new Email("Subject", "Message"); // create a new email
    $mailing = new MailingList($users); // create a new mailing list
    $mailing->sendEmail($email);
\end{minted}

Each object represents a specific, \textit{encapsulated}, bit of functionality, dealing with just the things that it needs to and nothing else. We still need to glue the objects together, but this code itself is generally inside other objects.



\section{(Almost) Pure OO}

Many object oriented languages \textit{only} use objects. For example in Java everything lives inside a class and you specify which class your app should create first when you run it.
\\

Because of PHP's history we always need a little bit of procedural code to get our objects up and running. This is often called the \textbf{bootstrap} file.

\php{bootstrap.php}{03/figures/03/04-bootstrap}

Once we've created our first object the idea of object-oriented programming is that we use objects from that point onwards.


\section{The Law of Demeter}

The ``Law of Demeter'' is a guideline for OOP about how objects should use other objects. Expressed succinctly:

\begin{center}
    \textit{Each object should only talk to its friends; don't talk to strangers}
\end{center}

In practice, this means that an object should only call methods on either itself or objects that it has been given. You should avoid calling a method which returns an object and then calling a method on that object: it requires too much knowledge about other objects.

\php{}{03/figures/03/07-Demeter}


\section{Types}

We've already looked at ``scalar types'' in PHP: integers, floats, strings, booleans, arrays, \&c.
\\

In OOP we generally talk of objects as having the type of their class: e.g. a \texttt{Person} object instance is of the \textit{type} \texttt{Person}.
\\

PHP supports \textbf{type declarations} for object instances too. These let us say that the values passed to and returned from a function or method must be instances of a certain type.
\\

For example, say we had a \texttt{MailingList} class with a \texttt{sendWith()} method. It would be useful to say that we can only pass \texttt{Mail} objects into this method\footnote{This is an example of \textbf{dependency injection}.}:

\php{}{03/figures/04/01-MailingList}

Before accepting the \texttt{\$mailer} parameter, we add the type declaration/hint of \texttt{Mail}. Now, if the user of that class tries to pass in something that isn't an instance of \texttt{Mail}, PHP will throw an error.

\php{}{03/figures/04/02-type-error}


\section{Why?}

Adding type declarations like this lets us find errors in our code quickly.
\\

For example, say that we didn't add the \texttt{Mail} type declaration and then passed in an object that didn't have a \texttt{send} method. We'd get an error from PHP, but it would say the error was inside \texttt{MailingList} when we use the \texttt{send} method.

\begin{minted}{text}
    Call to undefined method Person::send()
\end{minted}

But that's not actually the issue, the problem is that we've passed in the \textit{wrong} object type - one without a \texttt{send} method. So the error is actually when we pass the wrong type of thing to the \texttt{sendWith} method. By adding type declarations to the \texttt{sendWith} method we can make sure PHP finds the error at the correct point in our code.

\begin{minted}{text}
    TypeError: Argument 1 passed to MailingList::sendWith() must be an instance of Mail
\end{minted}


\section{Additional Resources}

\begin{itemize}[leftmargin=*]
    \item \href{https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)}{Wikipedia: Encapsulation}
    \item \href{https://stackify.com/oop-concept-for-beginners-what-is-encapsulation/}{What is Encapsulation?}: Uses Java for examples, but largely applicable in PHP
    \item \href{https://en.wikipedia.org/wiki/Law\_of\_Demeter}{Wikipedia: The Law of Demeter}
\end{itemize}
