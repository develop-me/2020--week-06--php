So far, all of the PHP code you've written has been ``procedural'': start at the top of a file, run through it, maybe call a few functions as you go, and then finish at the end. This is fine for simple programs or when we're just working inside an existing system (e.g. WordPress), but it doesn't really scale to larger applications.
\\

The problem comes because we need to manage \textbf{state}: keeping track of all the values in our code. For a large app you could easily have thousands of values that need storing. Naming and keeping track of all these variables would become a nightmare if they were all in the same global scope.
\\

\textbf{Object-Oriented Programming}\footnote{``Oriented'' not ``Orientated''.} (OOP) is one way to make this easier. The key idea behind OOP is \textbf{encapsulation}: we keep functions and variables that are related to each other in one place (an object) and then use visibility to limit which bits of code can access and change them.
\\

An object is effectively a black box: objects can send \textbf{messages} to each other (by calling methods), but they need not have any knowledge of the inner workings of other objects.


\pagebreak


\begin{infobox}{The Unusual History of PHP}
    PHP has a long and complicated history. The first version of PHP wasn't even a programming language, it was just simple templating language that allowed you to re-use the same HTML code in multiple files.

    \quoteinline{I don't know how to stop it, there was never any intent to write a programming language \textellipsis{} I have absolutely no idea how to write a programming language, I just kept adding the next logical step on the way.}{Rasmus Lerdorf, Creator of PHP}

    Over the years PHP morphed into a simple programming language and then into a modern object-oriented programming language. However, it wasn't really until 2009, with the release of PHP 5.3, that PHP could truly be considered a fully object-oriented language.
    \\

    Because of this gradual change, older PHP frameworks and systems (such as WordPress) were originally written using non-OO code, which is why they still contain a large amount of procedural code.
    \\

    PHP gets a lot of flack for not being a very good programming language and a few years ago that was perhaps a valid criticism. But in recent years, particularly with the release of PHP 7, it's just not true anymore. It certainly still has some issues, but nothing that a few libraries can't get around.

    \quoteinline{There are only two kinds of languages: the ones people complain about and the ones nobody uses}{Bjarne Stroustrup, Creator of C++}
\end{infobox}

\pagebreak


\section{Encapsulation}

Say that our app includes some code to send an email. If we were using procedural code we would probably have a function called \texttt{sendMail} that we can pass various values to:

\phpinputminted{03/figures/03/01-mail}

But we might want to be able to customise more than just the to, from, and message parts of the email. Which means we'd either need to have a lot of optional arguments (which becomes unwieldy quickly) or rely on global variables:

\phpinputminted{03/figures/03/02-global-mail}

But this is truly horrible: we have no way of preventing other parts of our code from changing these values and we would start having to use long variable names to avoid ambiguity in bigger apps.
\\

So, we want to store the variables and the functionality together in one place and in such a way that values can't be accidentally changed. This is where objects come in:

\phpinputminted{03/figures/03/03-mail-class}

Now if we need to add additional fields, we can just add a property and setter method


\section{(Almost) Pure OO}

Many object oriented languages \textit{only} use objects. For example in Java everything lives inside a class and you specify which class your app should create first when you run it.
\\

Because of PHP's history we always need a little bit of procedural code to get our objects up and running. This is often called the \textbf{bootstrap} file.

\phpinputminted{03/figures/03/04-bootstrap}

Once we've created our first object the idea of object-oriented programming is that we use objects from that point onwards.


\section{The Law of Demeter}
The ``Law of Demeter'' is a guideline for OOP about how objects should use other objects. Expressed succinctly:

\begin{center}
    \textit{Each object should only talk to its friends; don't talk to strangers}
\end{center}

In practice, this means that an object should only call methods on either itself or objects that it has been given. You should avoid calling a method which returns an object and then calling a method on that object: it requires too much knowledge about other objects.

\phpinputminted{03/figures/03/07-Demeter}


\section{Additional Resources}

\begin{itemize}[leftmargin=*]
    \item \href{https://en.wikipedia.org/wiki/Law\_of\_Demeter}{Wikipedia: The Law of Demeter}
\end{itemize}
