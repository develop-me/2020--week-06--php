You might look at the \texttt{MailingList} example from the previous chapter and think, ``What's the point of passing in the \texttt{Mail} object?'' And you'd be right. If we can only pass in a \texttt{Mail} object, then we may as well just create it in the \texttt{MailingList} class.
\\

But what if we wanted to be able to sometimes send our mailing list emails using the server's built-in mail program and sometimes using MailChimp? We can't have a type declaration for two different classes, but if we don't limit the type at all then you could accidentally pass in something that will break your code completely.
\\

This is where the idea of \textbf{polymorphism} comes in. Polymorphism is when two \textit{different} types of object share enough in common that they can take each other's place in a specific context.
\\

There are two ways to enforce this in most OO languages:

\begin{itemize}
    \item \textbf{Interfaces}: when an object implements a defined set of methods.
    \item \textbf{Inheritance}: when an object can inherit methods/properties from another object, creating a hierarchy of object types.
\end{itemize}



\section{Interfaces}

One way we can take advantage of polymorphism is to use ``interfaces''. An \textbf{interface} is a list of \textbf{method signatures} that a class can say it conforms to. It is a contract: if a class implements an interface then we are guaranteed that it has a certain set of methods taking a specified set of arguments.
\\

For example, rather than creating a \texttt{Mailer} abstract class, we could instead create an interface:

\php{MailerInterface.php}{04/figures/01/15-MailerInterface}

You can see that we list out all of the methods that a class that implements this interface \textit{must} implement. We would use it as follows:

\php{Mail.php}{04/figures/01/16-Mail-interface}

We would use it in \texttt{MailingList} in exactly the same way:

\php{MailingList.php}{04/figures/01/17-MailingList-interface}

Interfaces are also a type declaration. So, now we could only pass in classes that implement the \texttt{MailerInterface} interface.
\\

A class can \texttt{implement} as many interfaces as it likes:

\php{MailChimp.php}{04/figures/01/18-MailChimp}


\subsection{Message Passing}

If you look at the \texttt{sendWith()} method you'll see that it only uses the \texttt{to()}, \texttt{from()}, and \texttt{send()} methods of the object that gets passed in. Therefore it's \textit{guaranteed} that if the object passed in conforms to the \texttt{MailerInterface}, which defines all three of those methods, then it will work. That's not to say the implementation will necessarily work, but the \texttt{sendWith()} method has access to all the methods that it requires.
\\

This is a core idea in OOP. But one that is often not talked about with beginner level books on OOP. Although it's called \textit{Object}-Oriented Programming, it's not actually the objects that should get the focus, it's the \textbf{messages} that they can send to one another: the methods and their parameters.
\\

The reason interfaces are such a powerful idea is because they focus solely on the messages and don't tell you anything about the implementation. This is important because of encapsulation. If we have to worry about how a specific object does something, then we can't treat it as a black box.
\\

This is also why we try to only use \texttt{private} properties: if a property is \texttt{public} then we need to know about how the internals of the class work.



\section{Inheritance}

Inheritance lets us create a hierarchy of object types, where the \textbf{children} types inherit all of the methods and properties of the \textbf{parent} classes. This allows reuse of methods and properties but allowing for different behaviours.
\\

For example, say that we want to create a \texttt{Mail} and a \texttt{MailChimp} class. Both of these will be responsible for sending an email, so they will have some things in common, but their inner workings will be different. We could create a parent \texttt{Mailer} class:

\php{Mailer.php}{04/figures/01/07-Mailer}

We move all of the shared code into the \texttt{Mailer} class. We don't put the \texttt{send()} method into the \texttt{Mailer} class, as it will be different for each implementation. We can then \textbf{extend} the \texttt{Mailer} class to copy its behaviour into \texttt{Mail} and \texttt{MailChimp}:

\php{Mail.php}{04/figures/01/08-Mailer-children}

Now, in the \texttt{MailingList} class we can use \texttt{Mailer} as the type declaration. That means that depending on our mood,\footnote{Or possibly something more concrete} we can send messages with either the local mail server or with MailChimp:

\php{MailingList.php}{04/figures/01/09-MailingListRedux}


\subsection{Abstract Classes}

But you can perhaps see a few issues with this. Firstly, you could create an instance of \texttt{Mailer} and pass that into \texttt{sendWith()}. This would cause an issue because the \texttt{Mailer} class doesn't have a \texttt{send()} method, so you'd get an error. Secondly, there's no guarantee that a child of \texttt{Mailer} has a \texttt{send()} method: we could easily create a child of \texttt{Mailer} but forget to add it. This would lead to the same issue:

\php{}{04/figures/01/10-Mailer-oops}

This is where \textbf{abstract classes} come in. These are classes that are not meant to be used to create object instances directly, but instead are designed to be the parent of other classes. We can setup properties and methods in them, but they can't actually be constructed, only extended.
\\

We can also create \texttt{abstract} method signatures. These allow us to say that a child class \textit{has} to implement a method with the given name and parameters. We'll get an error if we don't.
\\

This gets round both issues: we won't be able to instance \texttt{Mailer} and we can make sure any of its children have a \texttt{send()} method:

\php{Mailer.php}{04/figures/01/11-Mailer-redux}


\subsection{Overriding}

Children classes can \textbf{override} methods and properties from parent classes. That means if we wanted to make it so that the \texttt{to()} method in the \texttt{MailChimp} class did something slightly different, then we could write a different \texttt{to()} method. As long as it has \textit{the same method signature}\footnote{The \texttt{\_\_construct()} method is an exception to this rule. As it is unique to the specific class it can have a different set of parameters.} (i.e. excepts the same parameters), this will work:

\php{MailChimp.php}{04/figures/01/12-override}

If necessary it's possible to stop a child class from overriding a method by adding the \texttt{final} keyword in front of it:

\php{Mailer.php}{04/figures/01/13-Mailer-final}

\subsection{\texttt{parent}}

Sometimes when we're overriding a method it can be useful to still have access to the parent object's version. For example, we might want to override the \texttt{to()} method of \texttt{Mailer}, but only to add a bit of functionality. We can do this by calling the method name on \texttt{parent}. Make sure you pass along the arguments when you do this:

\php{MailChimp.php}{04/figures/01/14-parent}

You can call the parent's constructor method with \texttt{parent::\_\_construct()}.



\section{Inheritance Tax}

\quoteinline{The object-oriented version of ``Spaghetti code'' is, of course, ``Lasagna code'': too many layers}{Roberto Waltman}

If you read any books about OOP they'll focus a lot of their time on inheritance. While inheritance can be very useful, all of this attention means that it's often the technique that programmers reach for when they need to add the same bit of functionality to multiple classes. And it will almost always lead to much more complicated code.
\\

That's not to say it isn't useful. It's totally fine to inherit code that frameworks or libraries provide, as in these cases you're generally adding one tiny bit of functionality to something that's much more complicated under-the-hood.\footnote{Although some purists would say even in this case there are better alternatives: see the \href{https://www.thoughtfulcode.com/orm-active-record-vs-data-mapper/}{Active Record vs Data Mapper} debate} But if it's code that you've written, it's always worthwhile thinking ``Do I really need to use inheritance?''
\\

Sandi Metz\footnote{She's been doing OOP since it was invented in the 70s, so she probably knows what she's talking about} suggests not using inheritance until you have \textit{at least} three classes that are \textit{definitely} all using exactly the same methods. You should never start out by writing an abstract class: write the actual use-cases first and only write an abstract class if you definitely need one. If you do use inheritance then try not to create layers and layers of it: maybe have a rule that you'll only ever inherit through one layer.



\section{Composition}

\quoteinline{Prefer composition over inheritance}{The Gang of Four, \textit{Design Patterns}}

The idea of \textit{composition over inheritance} is that rather than sharing behaviour with inheritance, we share it using interfaces and shared classes. If a lot of classes share the same implementation of a method, rather than using inheritance consider moving it into a separate class that they can all share. It might require a bit more code to get working, but it is much easier to make changes to.


\pagebreak

\section{Additional Resources}

\begin{itemize}[leftmargin=*]
    \item \href{https://phpapprentice.com/interfaces.html}{PHP Apprentice: Interfaces}
    \item \href{https://phpapprentice.com/classes-inheritance.html}{PHP Apprentice: Inheritance}
    \item \href{https://en.wikipedia.org/wiki/Composition\_over\_inheritance}{Wikipedia: Composition over Inheritance}
    \item \href{https://www.poodr.com}{Practical Object-Oriented Design in Ruby}: An intermediate book about OOP. In Ruby, but all the key concepts work in PHP too.
    \item \href{https://en.wikipedia.org/wiki/SOLID}{Wikipedia: The SOLID Principles of OOP}: Quite advanced, but incredibly useful if you can get your head round it.
    \item \href{https://www.youtube.com/channel/UCk3yOoaVtORwXipuLZ3jWNg}{YouTube: Sandi Metz Videos}: If you're doing OOP in a few years time, watch all of these. There's a lifetime of experience in these talks.
\end{itemize}
